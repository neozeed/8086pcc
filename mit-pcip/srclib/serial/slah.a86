|  Copyright 1984 by the Massachusetts Institute of Technology  
|  See permission and disclaimer notice in file "notice.h"  


| aux_hndlr - a package of routines to manage the auxiliary port

	.globl	_init_aux	|initializes port and interrupt vector
				|limited to 8 characters since c is limited
	.globl	_close_aux	|turns off interrupts from the aux port
	.globl	_getint
	.globl	_int_hnd	|interrupt handler
	.globl	__wake_serial	|restarts transmitter by turning on interrupts
	.globl	_serint		|number of spurious serial io interrupts
	.globl	_badtx		|bad transmitter interrupt count
	.globl	_slrint
	.globl	_slint
	.globl	_sltint
	.globl	_sllstat
	.globl	_slmstat
	.globl	_intcomp
	.globl	_sliir
	.globl	_PSEND		| sending a packet flag
	.globl	_DOSEND		| please, do send that character...

lcr = 0x3fb	|line control register
dla = 0x80	|divisor latch access
dll = 0x3f8	|low divisor latch
dlh = 0x3f9	|high divisor latch
datreg = 0x3f8	|data register
|mode = 0x1b	|8-bits, even parity
mode = 0x03	| 8 bits, no parity
int = 0x0c	|interrupt number for aux port
int_off = int*4	|offset of interrupt vector
mcr = 0x3fc	|modem control register
lsr = 0x3fd	|line status register
msr = 0x3fe	|modem status register

dtr = 0x0b	|bits to set dtr line
ier = 0x3f9	|interrupt enable register
rxint = 0x01	|enable data available interrupt
txint = 0x02	|enable tx holding register empty interrupt
tcheck = 0x20	| mask for checking on tx reg status on interrupt
rcheck = 0x01	| mask for checking rx reg status on interrupt
iir = 0x3fa	|interrupt identification register
imr = 0x21	|interuprt mask register
int_mask = 0xef	|mask to clear bit 4
int_pend = 0x01	| there is an interrupt pending
lstat = 0x06	| line status interrupt
rd = 0x04	| received data interrupt
wr = 0x02	| ready to xmit data
mstat = 0x00	| modem status interrupt
ocw2 = 0x20	|operational control word on 8259
eoi = 0x64	|specific end of interrupt 4
end = 245	|end of packet indicator
req = 243	| request indicator

	.text

| init_aux(divisor) - initializes 8250 and set up interrupt vector to int_hndlr
|			divisor is the divisor for the baud rate generator

_init_aux:
	cli
	push	bp
|***** ***** ***** *****  EXTRANEOUS STUFF TO FIND OUT HOW 8250 WORKS  *****
|	mov	dx,*ier		|let's find out what we start with.
|	in
|	mov	_slmstat,ax	|statistic mstat is enable register at entry.
|
|	mov	dx,*iir		|check iir on chance enable is non-zero.
|	in
|	mov	ah,*0		|clear high byte
|	mov	_sliir,ax	|statistic iir is iir at entry.
|
|	mov	dx,*ier		|prepare to enable
|	mov	al,*0		|first, disable
|	out
|	mov	al,*txint	|now enable for xmit condx.
|	out
|	mov	dx,*iir		|look to see what condx are there now
|	in
|	mov	ah,*0		|clear high byte
|	mov	_sllstat,ax	|statistic lstat is iir after xmit enable.
|	mov	dx,*ier		|now cycle the xmit enable bit.
|	mov	al,*0
|
|	out
|	mov	al,*txint
|	out
|	mov	dx,*iir		|look at condx again.
|	in
|	mov	ah,*0
|	mov	_slint,ax	|statistic slint is condx after xmit cycle.
|***** ***** ***** *****  END OF EXTRANEOUS STUFF  ***** *****
	mov	bp,sp
|					reset the UART

	mov	dx,*mcr
	in
	mov	oldmcr,ax		| save the old mcr
	mov	al,*0
	out
|clear_int:				clear out any lurking conditions
	mov	dx,*lsr			|reset line status condition
	in				
	mov	dx,*datreg		|reset receive data condition
	in
	mov	dx,*msr			|reset modem deltas and condition
	in

	|set baud rate with the passed argument
	mov	dx,*lcr
	mov	al,*dla+mode
	out
	mov	dx,*dll
	mov	al,*4(bp)	|low byte of passed argument
	out
	mov	dx,*dlh
	mov	al,*5(bp)	|high byte of passed argument
	out

	|set 8250 to 8 bits, no parity
	mov	dx,*lcr
	mov	al,*mode
	out

	|set interrupt vector
	push	ds
	mov	ax,*0
	mov	ds,ax
	mov	bx,int_off
	mov	cx,int_off+2
	mov	int_off,*_int_hnd
	mov	int_off+2,cs
	pop	ds
	mov	int_addr,bx		|save the original interrupt vector
	mov	int_segment,cx

	|enable interrupts on 8259 and 8250
	in	imr			|set enable bit on 8259
	and	al,*int_mask
	out	imr
	mov	dx,*ier			|enable interrupts on 8250
	mov	al,*txint		|set a lurking xmit interrupt first
	out				|ZAP!
	mov	al,*rxint		|now enable for receive only
	out
	mov	dx,*mcr			|set dtr and enable int driver
	mov	al,*dtr
	out

|	mov	al,*0x0a		|read the irr
|	out	ocw2
|	in	ocw2
|	mov	al,*0x0b		|read the isr
|	out	ocw2
|	in	ocw2

	pop	bp
	sti
	ret

| close_aux - turns off interrupts from the auxiliary port

_close_aux:
	|turn off 8250
	mov	dx,*ier
	mov	al,*0
	out

	|turn off 8259
	cli
	mov	dx,*imr
	in
	or	al,*~int_mask
	out

	|reset interrupt vector
	push	ds
	mov	ax,*0
	mov	bx,int_addr
	mov	cx,int_segment
	mov	ds,ax
	mov	int_off,bx
	mov	int_off+2,cx
	pop	ds

	mov	dx,*mcr		| restore old mcr
	mov	ax,oldmcr
	out

	sti
	ret

_getint:
	push	ds
	xor	ax,ax
	mov	ds,ax
	mov	ax,int_off
	pop	ds
	ret

| int_hndlr - handles interrupts generated by the aux. port

_int_hnd:
	sti
	push	bp
	push	ds
	push	di
	push	ax
	push	bx
	push	cx
	push	dx

	|set up data segment
	mov	ax,cs
	add	ax,#_data_seg
	mov	ds,ax

	inc	_slint

|	mov	dx,*ocw2	|tell the 8259 that we want more.
|	mov	al,*eoi
|	out

	|find out where interrupt came from and jump to routine to handle it

	mov	dx,*iir
	in
	cmp	al,*rd
	jz	rx_int		|if it's from the receiver
	cmp	al,*wr
	jz	tx_int		|if it's from the transmitter
	cmp	al,*lstat
	jz	lstat_int	|interrupt because of line status
	cmp	al,*mstat
	jz	mstat_int	|interrupt because of modem status
	inc	_sliir		|we got an interrupt but none was pending
	jmp	int_end		|go finish this interrupt.

repoll:
	mov	dx,*lsr		|we always expect received data, so
	in			|check status to see if any is ready.
	and	al,*rcheck	|get received data bit
	jnz	good_rx		|yes, go accept the byte.

	mov	dx,*ier		|look at transmit condition
	in			|to see if we are enabled to send data.
	and	al,*txint	|
	jz	int_end		|not enabled, so go finish this interrupt.
	mov	dx,*lsr		|we are enabled, so look for tx condition.
	in
	and	al,*tcheck
	jnz	goodtx		|transmitter is finished, go get more data.
	jmp 	int_end		|tx busy, nothing else to do but exit.

tx_int:
	mov	dx,*lsr
	in
	and	al,*tcheck
	jnz	goodtx		|good interrupt

	inc	_badtx		| bump counter
	jmp	repoll		|see if any more interrupts

goodtx:
	inc	_sltint		| count number of valid tx conditions
	call	_sl_bout	| actual output routine can be in C
	cmpb	_DOSEND,*0	| should this byte be sent?
	jz	nosend

	mov	dx,*datreg	| now output the byte
	out			| it was in al

nosend:
	cmpb	_PSEND,*0	| check if still active
	jnz	repoll		|see if any more interrupts

Ldie:	mov	dx,*ier		| if it was, turn off interrupts
	mov	al,*rxint
	out
	jmp	repoll		|go look for other conditions

rx_int:
	mov	dx,*lsr		|check to see if read is real
	in
	and	al,*rcheck	|look at receive data bit
	jnz	good_rx		|real, go get byte
	inc	_intcomp	|must be a left-over signal.
	jmp	repoll		|go look for other conditions

good_rx:
	inc	_slrint
	mov	dx,*datreg	| get the byte
	in
	push	ax		| the argument to _sl_bin
	call	_sl_bin		| call a possible C routine
	pop	ax		
	jmp	repoll		|see if any more interrupts

lstat_int:
	inc	_sllstat
	mov	dx,*lsr		|clear interrupt
	in
	jmp	repoll		|go look for more interrupts

mstat_int:
	inc	_slmstat
	mov	dx,*msr		|clear interrupt
	in
	jmp	repoll		|go look for more interrupts

|repoll:
int_end:
	mov	dx,*ocw2	|tell the 8259 that we want more.
	mov	al,*eoi
	out
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	pop	di
	pop	ds
	pop	bp
	iret


__wake_serial:
	cli
	mov	dx,*ier		| turn on serial interrupts
	in
	or	al,*txint
	out
	sti
	ret


	.data
int_addr:	.word		|the initial contents of the serial line's
int_segment:	.word		|interrupt vector

		.word	0
_sltint:	.word	0
_slrint:	.word	0
_sllstat:	.word	0
_slmstat:	.word	0
_intcomp:	.word	0
_slint:		.word	0
_sliir:		.word	0
_badrx:		.word	0
oldmcr:		.word	0
